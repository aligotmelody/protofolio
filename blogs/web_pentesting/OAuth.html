<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <base href="https://aligotmelody.github.io/protofolio/">
    <title>OAuth Simplified: A Hands-On Breakdown</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAADhCAMAAAAJbSJIAAAAwFBMVEVEyXP///8AAABGznbZ8uE0xmothEywsLBG0HciZDlDxXFBwW5Gz3cLIBI2oVwYRSg0mVg9tGcuiU4ECwYTOCAPLRoZSysOKRcylFU8sWU5qGBCwm9AvGwod0QrgEkJGg8eWTNJSUkUOyIlbD5cXFw4pV4cUi8WQiYvt2FnZ2cKHhHf398mcEAHFQw+Pj4wj1IgICDJycmioqLz8/Nm0YozMzOWlpZycnKFhYXNzc27u7vk5OQVFRUiIiIGEQpZuHkZVSe3AAAP+ElEQVR4nO2d+1/iuhLACzkHA1QE5f0S8bEr6rIrV931nPX+///VbUs7M0kmoUqRsrfzk58S03yb5jWveqU/Xbx9N2DnUhAevhSEhy8F4eFLQXj4UhAevvwfE65+PN9eXFwdfWZjPiRHVxcXt88/VrbfLYR3t+VYrnbVsozkKmno7R1fgCX8B/4tkOddtm9reSYtvWIZOcLHMpWnv/IsT0pbH9MRvij/VD77+nd+5euZ2tiXNIS36v+UFzUvv1JbaK293Uz4U/uXclXuG8Mhsqo39+cmwlf9P47z3IVBJx7rDX7dQGj0YL4BPW9k9KKbkL6js2bLk3l+RdcSNHHcnNnfU5VwheXaAyn23fjUIuSgjU1fOQiPoNRJ7XD4QhG1E2j7kYMQ9jK5XiJ4GcHCcWUnXP1OCjUPqwdDEf2k8b9XVsI76Gg/XaXSMROJ8FcpRbpn5awKK3NV4UPr76yEv2CNSDeFTuedaou/q5DX05t2p30zvU4xYwlv0u5cjm0FpWhMgsrms8rQURmu/r+shLDcT1M8eDFev/gNpqyoTcj0PRltqE601gWv2XKifo91PVSsU6CYJoVerYQwlVZSPPbxeVy4bv62LCtytnTWJ1oPcTn214pa2bltjsCCR1kQinEvKXxqFJ6Vdak6AZNnVe6b9611jcouLQMjU0Ixxv2gMWi/GG0K1lcHIJ6AmPt2mMpu2IkwU0J8RU1CccO0KWiVZfJKxqDlvnO2MnYmzJKQ9qB+OxzvmpyyiOQVZe4r7y2VMa9zloRkDJqEY0ubyuUxC/hAi2j3FQNbXYvRLgmTZYIl9I3DDMilOXqE9jx0Qv6FD4VZzzIjFPVz9WYKYQ2v95aD8eAU3+c3Y1kRrTcnIeFvh5VV8M7HTMMyIlTHoE5IVsKbaGmWZLbXB486Bs37kiFd9cJf/DqekczdgWgmv9n3NCkItTGoE0pYCtvwHwuuYFTVm16Vel8Jy85JfF2MYNhOmCbGy85TaQtCZZngCIEfNnP4aL+oVbWMmnRCuD5MrsvT5FKXGdWN9U93WxCKuq6907smecYPeMCEoXmuAprPSr9vcrmDl2BoHjOLjxjMOp2Xf0ofJ2ReUY1wlOxPeuQi/BM5VrOA2n2B5gQrg2nujF1eZe0/pdLHCdVJBrQGlLDOEcLGq0aqomAwGaUghCZY9khbESrLxGS4BSHdiwa7neucEEq6o57IxjZ9OCdVTbGqrQl9uQ3hEBtVvvfFFoTimlQ19XG23ZJQtGa93u2HZxpsR9iD3laE5FBbkV5WhCLug4+uFogUrbZbEYJaLATMjNCLdzzfPvqWwroWbSe2IcS2T8NiWRFCebuuzU2YPPn7qO6tCJPXdBptTDIixNH9UULPbwRt7fXXVW9F6Ml+sA3oNOOq8tKHoV621fKSTfBWhEEtrVaiLM5sHMY3+vA41Gi3I1Sqyngu/fXHEgY775uzN92v5o8iDM2lW+1LD4Bwy513QVgQ7p5Q1gf/1Z0UMyaEMz5RMoDLy9k7CevJ5S+EMFGTvHFzaWVRLv8+2imhSBpwhspRaCij43QSiuRyDx8NqK96zHoYax8fd0ko4Y1cJld9OCp1bfotCyHq2sBk6IPldebYtdnt+BkQglL/PLZZC+jCeMv+DkJQ6vdiwy8xZJhqfdRG/9jlW4rH5E5LCiHkALVXnD3cRShAOVpu16PKhqjeGZjVZGsDthDi2Alk1m8siTm4Z/PRsRF6I1JZNaiMGGraTDWfREhdFFSZ2hw8rITi0loZ4xnwSYTeiNP0hrKwV2Uj9MZnlsqYLvw0QqqwUoR3JXEToplCk8FubcBOQk/y76n1HXURMj7AkSy5yjInBK3IpXY7yY2ee5fN1aIRjn4zPVdsTytrQrQMGV4DjLOC6XNDBTYqzHrCTF2cm8IuCJOuYmYQxZ81kHnL7SeX2FXbrDFhqBq8Tmzub9n34foFOuZcLDzZ6CYG3rebxmY/wMj61Gar8oRsdpM59Xw2tFaWPaEnhveXfYsjnZDj68pl9b4yHKfxphaN+8um/degsmlQ2emw7qhsB4Sh16drAhHp3Us3VJWqsl0Q5ksKwoIw/1IQFoT5l4KwIMy/FIQFIa0qDLLyN+6phR8V21QqKpY+mlNYy2bmBS0Hy2r3pDurDF2MQgxPZ0Gx6qkrGCssVomKLdOFrIr6pNud8ie2bAiFWGIQy2Jii7IS3hRV3b1Tz1asNsFghE5/80lLDKKj8II9KmdCKK41bSgfskW8uiJ544Ox9Jit3vUGZQCYLdpcWFAWhIxWaMap6k0V4CVXnRlN4VA5euhNEshwN4Ss8nJu3smMNiuXb4waa22mmK6ZVOodoAaceym2J7QEIZ1oZVkNJ2Pv4yLcIr9OKyApthNCq7pebZQ+uEDUIWuN2bKa4KgD724IzQwUiSimPHtklxIUZI/ZskwBQ8VIswtCa98ELyApzar010JNwJIbq2th1eN6FNtO+hC78GwyVEK2lLg7vPpQGYyHU1zwHkgnkgb3ToNiZJI+5hqvd/kOCMkw6EQ6XkGifdGmTlbCbi10cPZHOKNgs8iyMwu3A0K2cGYdum6+JSEkiDLfFGzTWz35cZ5cQo8eH7A7sFDCJgGXAgnhKBCzhePX8EGgy4SLEIyNdkLI3WJuVXxYnitJO8mTxab3jDZgt2JkF3o2galTgsFKjxjmIklZQvDF+GklvEiKmFsGCW0igw62qHi/dJFdYE4jnk1w7UQlZENl2W0gPPELGyEkjWAc0CRYf3C+wCAauMZFdtXMyC6gIf5c4B+k7pK0ZcJFiPGrdxbCb3Bf87/h/seEEEYT9GtKzz0g7DKEiheC2oPwSPmt/Dz5+RtPiHnamDDiPRGqgH2YS1hCYnt+YQhXJE8bc/zaE2GNntaWEtYDvg/Jfup2pRKu7p7/xV9nzL/vh1A5aC6l2EBIN/3/Pt+tEsLHp+8EL5AW88/7IaR7wFPpbSL01NDif78/PYaEF2VN2GPonvoQ9z6hC81GQml4gVyUvEf9Wpc9oe1pHMISF/kIbSRkdvSP3pN2pc17EO6JMElCsXaC2kxoag6ePO1C2ZL3aW/rYfieHsf+KikIzSj/nPdhcNkbthJV6sf6MN/jUJWPjcNcz6XvJWTn0lyvh+8l5NfDSO6ev+Mv+dnTvJOQ7mm+P9/p+1KSIDk/+9L3EZJ96Yu2L83t2eJdhGQHxJ0ttjofwrX99uE8+dlyPiSpL11nfHyF8YwPmbdSRnZxZ3yI1JjbXd7dhJvP+E49DagicKZF9QSqCZnILogLwcguHDBICGfdE3ZBTkG4WU+TTtc2SWx3JI0E6trgjQRnbJL4CGodwbPB/EhgyGBitlIRptG1ufSluJYmO9ca0KD+Dw1wi1itKjC0h9OXJoOOqCscabjchCn0pS6tPrZgMYiirOqozMYHQgxU7XFUrIVWcTQrkefVjWO2MAGVGbOVknBbuwVJQjlrDhv3RMlHrUp4tXzZHDaJUZVmXyabj7NJY0jzcXccoSc7JdSzrhKpktIpI7skb0YNxRJNsXtCPpNoJMo+tv5gKXWuLEFWM6OjC3dNaBqAksKqDbhvKaYad81TQCym5enTCD3UViqiT+4+byPVQ2QteS35LKefRMhHpZlOFqzLBpP7l0Pc4G7i1Hln4k9jhgNyjjLMbMOmzzY7m426IxXDHoNbUbLxiWrNlRad854TQgvG6vDBSqKpzkpfLFowFD+ul9W0ZOS551+jJqS9tHmiCdnER/GlaS0m+jhBdzf5fIWyTtzIa8uy802sN6bVWXXSbDmdDuW4MQmKTRvOyK5gz9NcF3PFbFFZVqsWFUaW/qVC+pvdS0PPUT9FZFfKYlDc37V/aX6lICwI8y8FYUGYfykIC8L8S0FYELJ1bkiEkBRzBm6lS72wn5wK4tqeF4NK49Ka8yI8ZKXIeLGvvBhxbpMNZWuRbnxufvcq7JgmKM7tWUuEj7lNHj4zt4mIG2fPcBWVGsWn+LkZjOVfq8qOLvuw9pefBrQZDiW1J/C7KYYiVJhhM00mGeLecgyhusYVjTVCBx7DnsUp9it6XXvLE0Xj0xyfEqwRS4BGaAkA62uJw/aW64sGnlkJYQwyhOkyse0vX5viW2UlrCs+Ziqh1TLTprXtLeee6jxmI9Sc6BRCh3WN6Ar3lTdRnKg3sxDWNGucQki78LLfWJJnRjpxX7kvNUDLp/rqurmREpJQvy9rK/c1KvjBJrGv/KWGfyNLODKifCkhOkkmn3KSQ7Pge3PQZkPIhDFzhPorqhGiJw5kxES3/Fmy+3HnETb2SBllHGDik01CdZlgCNN5DL0zF3Q2hFxwq0Eo6lwgOiVM5/XF5fMe2/N5Z0JIAeFFMwiVZQJ6kyV0eu4BYcqvsGxPqIzBri1DqzoGq+BC9H7C935nZntPBbpKdzFDq/5ZQ/ocqhJcMw6AkDpRd+15hKlTStUXB0RIcyp0PTshcZSpCu9ACbuegxC3K6E32CER4g27noMQ17Xo+kERJg5DXc9JmBxt1/58B0UYq0ziz6RbCeMEPPG3Xg+L0JOjZrPubyT06/1mokY9MMJQwwl/2QmVYodGSOpzEZJiBWFBWBAWhAXhrglPGELI3sKegO3f5c4n4QPRT5g8yZV031bPFSF+hB5iNfDTXhBFhbo2jP/CMLEd6doyIsTIxaSh5NNeoAnFUpAvawSK48mu9KXZEBKzZzVKbuqP52aHkcN0XIoo8cxPD+WKkGaka/db4wFJXEcy0hHrRns5CEphPh7mO3z5IpSMZtm8tyWuJhQmgCNfhGyKskjeRJpSi5Fxp5wR2szXWgCYNQforqKCMiSET71rogeAzdlSvEFvT4SszjuUkeomE9dl3JiLerzhEiVn708DE53ze1yoIDZCpGq6qTXoQbPpNdMYZPnCWfbf7EpuzX+HCiR+G8+ZKrUoyx776Ss9NezClpsmDeFrUoQNptMl3ubbEv8mEu9BWf+QMZlJHmyJzUWdlqpYXQVxg/BqJYTUkM6hhVKZty83Oe6Fidfb7fs6X0yKxqTb7sxnp66s81I2JjdhqYorhT1Oz7+shJgYgx3KZuOlTPMonP6lIv4OwYYqolJub1bcqN9ZCVe/kzIub7ycCq5Lv+3fAy5dwXC2ffc1vzKCE9lVyU4Ik2n5JIXvb55EkLXnyEG4wkmrne6DE/kQoXxTcuUgxPwt5TD7xdhLNZPsV4ImjmlejfJzyUVYKmtSZTbxuZKRsYUvuQlf9fI5n3NqC73BrxsIlfd03Yt5flHNQ9hPHcggLN1q/5LrTjS68NbgMQlJ3rZIzr7+nV/5qjkRv5g4DGFJTYf59FeeRU1O+sjQcISlf67Ifz1zJXIjz6SlV3dcCZYw2IPDaLziC+RGoDNeWD4rYSA/nm8vLq6OrL/nRY6uLi5un39Yf7cT/ilSEB6+FISHLwXh4UtBePhSEB6+FISHL/8Dr0KYuUoS5IwAAAAASUVORK5CYII=" type="image/x-icon">
</head>
<body>
    <main>

<div class="container">
    <header>
        <div class="container">
            <div class="header-content">
                <a href="#" class="logo">ali@<span>blogs</span>:$</a>
                <nav>
                    <ul>
                        <li><a href="/protofolio/">home</a></li>
                        <li><a href="/protofolio/blogs.html">blogs</a></li>
                    </ul>
                </nav>
            </div>
        </div>
    </header>

    <div class="terminal-window post-container">
        <div class="terminal-header">
            <div class="terminal-buttons">
                <span class="terminal-button close"></span>
                <span class="terminal-button minimize"></span>
                <span class="terminal-button maximize"></span>
            </div>
            <div class="terminal-title">view_post.sh --target oauth_simplified.md</div>
        </div>

        <div class="terminal-body">
           
            <article class="post-content">
                <header class="post-header">
                    <h1 class="section-title">OAuth Simplified: A Hands-On Breakdown</h1>
                    <div class="post-metadata">
                        [DATE: 2025-01-03] [AUTHOR: ALI] [TAGS: SECURITY, OAUTH, WEB]
                    </div>
                </header>

                <h3 class="sub-header">Introduction</h3>
                <p>
                    Hey there, in this blog post I'll try to simplify how OAuth works and break down what actually happens behind the scenes.
                </p>
                
                <p>
                    So I built a small server and a segment of the client app that would handle the OAuth request.
                    I decided to take this approach because I couldn't really pinpoint the attack vectors of OAuth with just the theory of how it works. I needed to build it in order to understand how to break it. Anyhow, enough with the introduction let's get into it.
                </p>

                <hr>
                <br>

                <p>
                    So before we start anything, let's make sure you understand the terminology that will be used. Additionally, I'll give you a mental model of the context in which we will be implementing the OAuth functionality:
                </p>

                <h3 class="sub-header">Terminology</h3>
                <p>
                    <span class="highlight">The Frontchannel (The User's Browser)</span>
                </p>
                <p>
                    The Frontchannel is like a public courier. When the Auth Server wants to send a code to the Client App, it gives it to the browser (the courier) via a URL redirect.
                </p>
                <p>
                    <span class="accent">The Risk:</span> Because the data is in the URL, it's visible in browser history, server logs, and can be intercepted by malicious browser extensions.
                </p>
                <p>
                    <span class="accent">Analogy:</span> Sending a postcard. Anyone who handles the postcard can read what's written on the back.
                </p>

                <p>
                    <span class="highlight">The Backchannel (Server-to-Server)</span>
                </p>
                <p>
                    The Backchannel is like a private secure line. Once the Client App has the temporary code, it calls the Auth Server directly over a secure HTTPS connection (using a library like axios or fetch).
                </p>
                <p>
                    <span class="accent">The Security:</span> This connection is encrypted. The user never sees the data being exchanged (like the code_verifier or the access_token).
                </p>
                <p>
                    <span class="accent">Analogy:</span> A private phone call between two offices. No one on the street knows the conversation is even happening.
                </p>
                <p>
                    In this system, the flow moves between the <span class="highlight">User's Browser</span> (Frontchannel) and <span class="highlight">Server-to-Server</span> (Backchannel) to ensure security.
                </p>

                <h3 class="sub-header">Mental Model</h3>
                <p>
                    To make it clear, the server I built is a <span class="highlight">Custom OAuth 2.0 Authorization Server</span> using the <span class="highlight">PKCE</span> extension.
                </p>
                <p>
                    While Google acts as a "Public Identity Provider" for the whole world, this server is currently a "Private Identity Provider." Here is the exact context where this type of server is used:
                </p>

                <h4>1. The "Internal Ecosystem" Context</h4>
                <p>
                    This is the most common real-world use case. Imagine you are building a company called "TechCorp" that has:
                </p>
                <ul>
                    <li>A <span class="highlight">Main API</span> (Resource Server) that holds user data</li>
                    <li>A <span class="highlight">Mobile App</span> (iOS/Android)</li>
                    <li>A <span class="highlight">Web Dashboard</span> (React/SPA)</li>
                    <li>A <span class="highlight">Desktop Tool</span></li>
                </ul>
                <p>
                    Instead of writing login logic for <em>each</em> app, you build <strong>one</strong> Authorization Server (the one used here). All your different apps "Sign in with TechCorp" by talking to this single server. It centralizes your security.
                </p>

                <h4>2. The "Third-Party Developer" Context</h4>
                <p>
                    <span class="accent">Context:</span> You have a platform (like a CRM or E-commerce engine) and you want outside developers to build "Apps" or "Plugins" for it.
                </p>
                <p>
                    <span class="accent">Role:</span> You give those developers a <code>client_id</code>, and they use the flow you built to let users "Authorize" their third-party apps to access your platform's data.
                </p>

                <h4>Why I used PKCE specifically?</h4>
                <p>
                    This server is specifically designed for <span class="highlight">Public Clients</span>. These are apps where the source code is visible to the user (like a Mobile App or a React site).
                </p>
                <ul>
                    <li><span class="accent">Without PKCE:</span> A hacker could intercept the <code>code</code> from the browser and use it.</li>
                    <li><span class="accent">With PKCE:</span> Even if they steal the <code>code</code>, they can't use it because they don't have the <code>code_verifier</code>.</li>
                </ul>
                <br>

                <hr>

                <h3 class="sub-header">UML Diagram</h3>
                <div class="image-container">
                    <img src="https://8upload.com/image/9a1752147ecbb01d/uml_diagram.png" alt="UML Diagram showing client_app and server interaction">
                </div>

                <h3 class="sub-header">Step 1: The Setup (Client App Internal)</h3>
                <p>
                    Before any request is made, the Client App prepares a "secret handshake."
                </p>
                <p>
                    <span class="accent">Functionality:</span> The client generates a <code>code_verifier</code> (a random string) and a <code>code_challenge</code> (a hash of that string).
                </p>
                <p>
                    <span class="accent">Purpose:</span> To prove later that the app that started the login is the same one that finishes it.
                </p>

                <div class="code-wrapper">
                    <div class="code-header">client_app.js</div>
<pre><code>// Step 1: The Setup (Client App Internal)

// Helper: Generate a random string for PKCE
const generateRandomString = () => crypto.randomBytes(32).toString('hex');

// Helper: Hash the string for PKCE (S256)
const generateCodeChallenge = (verifier) => {
    return crypto.createHash("sha256").update(verifier).digest("base64url");
};</code></pre>
                </div>

                <h3 class="sub-header">Step 2: The Authorization Request (Frontchannel)</h3>
                <p>
                    <span class="highlight">Endpoint:</span> <code>GET http://localhost:4000/authorize</code>
                </p>
                <p>
                    <span class="accent">The Request:</span> The browser is redirected from the Client to the Auth Server with parameters like <code>response_type</code>, <code>client_id</code>, <code>redirect_uri</code>, and the <code>code_challenge</code>.
                </p>
                <p>
                    <span class="accent">Functionality:</span> The Auth Server checks if the <code>client_id</code> exists and if the <code>redirect_uri</code> is on the pre-approved "Allowlist."
                </p>
                <p>
                    <span class="accent">Storage:</span> The Server generates a temporary <code>authorizationCode</code> and saves the <code>code_challenge</code> in its <code>Map</code>, linked to that code.
                </p>

                <div class="image-container">
                    <img src="https://8upload.com/image/81f503f251eee5ce/authorize.png" alt="Authorization Request Flow">
                </div>

                <div class="code-wrapper">
                    <div class="code-header">client_app.js</div>
<pre><code>// Step 2: The Authorization Request (Frontchannel)
app.get("/login", (req, res) => {
    
    // 1. Create PKCE Verifier and Challenge
    currentVerifier = generateRandomString();
    console.log("verifier :" + currentVerifier)
    const challenge = generateCodeChallenge(currentVerifier);
    console.log("code challenge :" + challenge)
    
    // 2. Build the Auth Server URL
    const authUrl = `${AUTH_SERVER_URL}/authorize?` +
    
        `response_type=code&` +  // specifying the grant type
        `client_id=${CLIENT_ID}&` +
        `redirect_uri=${encodeURIComponent(REDIRECT_URI)}&` +
        `code_challenge=${challenge}&` +
        `code_challenge_method=S256`;
        
    // 3. Send user to the Auth Server
    res.redirect(authUrl);
});</code></pre>
                </div>

                <div class="code-wrapper">
                    <div class="code-header">server.js</div>
<pre><code>app.get("/authorize", (req, res) => {

const {
response_type,
client_id,
redirect_uri,
code_challenge, //the hashed code challenge
code_challenge_method // specification of the hash used
} = req.query;

// 1. Validate response type
if (response_type !== "code") {
    return res.status(400).send("Unsupported response_type");

};

// 2. Validate client
const client = clients[client_id];

if (!client) {
    return res.status(400).send("Invalid client_id");
};

// 3. Validate redirect URI
if (!client.redirectUris.includes(redirect_uri)) {
    return res.status(400).send("Invalid redirect_uri"); // checking the redirect uri against the allow list
};

// 4. Enforce PKCE
if (!code_challenge || code_challenge_method !== "S256") {
    return res.status(400).send("PKCE required");
};

// ---- Fake login success ----
const authorizationCode = crypto.randomBytes(32).toString("hex"); // Think of this as a "Claim Ticket" a user gives you. It proves that the user just logged in and gave you permission.
console.log("authorization code :" + authorizationCode + " for client : " + client_id);

authorizationCodes.set(authorizationCode, {
client_id,
redirect_uri,
code_challenge
});

// Redirect back to client

const redirectUrl = `${redirect_uri}?code=${authorizationCode}`;
res.redirect(redirectUrl);

});</code></pre>
                </div>

                <p class="side-note">
                    <span class="accent">Side note:</span> So here is a fun fact about the request to <code>app.get("/authorize")</code>. At first I thought we should use the *post method* here but turned out although standard APIs usually use <code>POST</code> for creating data, but the OAuth 2.0 specification (RFC 6749 section 3.1) actually <strong>requires</strong> the <code>/authorize</code> endpoint to support the <strong><code>GET</code></strong> method for multiple reasons (mainly because it's a redirect).
                </p>

                <h3 class="sub-header">Step 3: The Code Delivery (Frontchannel)</h3>
                <p>
                    <span class="highlight">Endpoint:</span> <code>GET http://localhost:3000/callback</code>
                </p>
                <p>
                    <span class="accent">The Request:</span> The Auth Server redirects the user's browser back to the Client's callback URL, attaching the <code>code</code> in the URL.
                </p>
                <p>
                    <span class="accent">Functionality:</span> The Client App catches this code from the URL.
                </p>
                <p>
                    <span class="accent">Security Note:</span> At this point, the Client has the <strong>Code</strong>, but it doesn't have a <strong>Token</strong> yet.
                </p>

                <div class="image-container">
                    <img src="https://8upload.com/image/b800ace9bd4ac246/callback.png" alt="Callback Response">
                </div>

                <p>
                    As shown above, we've finished the front channel section of the UML diagram:
                </p>

                <div class="image-container">
                    <img src="https://8upload.com/image/08d4aa3bb96a54c8/front_channel.png" alt="Front Channel Completed">
                </div>

                <h3 class="sub-header">Step 4: The Token Exchange (Backchannel)</h3>
                <p>
                    <span class="highlight">Endpoint:</span> <code>POST http://localhost:4000/token</code>
                </p>
                <p>
                    <span class="accent">The Request:</span> The Client App sends a direct "Backchannel" POST request to the Server containing the <code>code</code> and the original <code>code_verifier</code>.
                </p>
                <p>
                    <span class="accent">Functionality:</span> 
                    <p>
                        1. The Server retrieves the saved <code>code_challenge</code> from its <code>Map</code>.
                    </p> 
                    <p>
                        2. It hashes the <code>code_verifier</code> sent by the client.
                    </p> 
                    <p>
                        3. If <code>Hash(verifier) === challenge</code>, it proves the request is legitimate.
                    </p>
                </p>
                <!-- <p>
                    <span class="accent">Cleanup:</span> The Server <strong>deletes</strong> the code from its <code>Map</code> (making it single-use).
                </p> -->

                <div class="code-wrapper">
                    <div class="code-header">client_app.js</div>
<pre><code>app.get("/callback", async (req, res) => {
const { code } = req.query;
if (!code) return res.send("No code received from Auth Server.");

try {

// 4. Exchange the Code for a Token
// We send the 'currentVerifier' that we saved earlier
const response = await axios.post(`${AUTH_SERVER_URL}/token`, {
    grant_type: "authorization_code",
    code: code,
    redirect_uri: REDIRECT_URI,
    client_id: CLIENT_ID,
    code_verifier: currentVerifier
}

// uncomment if you want to see the request using a proxy
// ,{
// proxy: {
// protocol: 'http',
// host: '127.0.0.1',
// port: 8080
// }}
);
const { access_token } = response.data;</code></pre>
                </div>

                <p class="side-note">
                    <span class="accent">Side note:</span> Some of you might be wondering why we're sending different grant_type parameters (<code>response_type</code>, <code>grant_type</code>). Here's an explanation of the difference:
                </p>
                <ol>
                    <li><span class="accent"><code>response_type</code>:</span> Tells the server what to send back to the <strong>user's browser</strong> (a "code" or a "token").</li>
                    <li><span class="accent"><code>grant_type</code>:</span> Tells the server what credentials the <strong>Client App</strong> is presenting to the private API (an "authorization_code", a "password", etc.).</li>
                </ol>

                <div class="image-container">
                    <img src="https://8upload.com/image/b5a77bb01771d545/token_request.png" alt="Token Request Flow">
                </div>

                <h3 class="sub-header">Step 5: The Response (Backchannel)</h3>
                <p>
                    <span class="highlight">Response:</span> <code>200 OK { "access_token": "..." }</code>
                </p>
                <p>
                    <span class="accent">Functionality:</span> The Server sends the <code>access_token</code> back to the Client.
                </p>
                <p>
                    <span class="accent">Result:</span> The Client App now has a valid token to make API requests, and the user is officially "logged in."
                </p>

                <div class="image-container">
                    <img src="https://8upload.com/image/0e35f415ee851567/acces_token.png" alt="Access Token Response">
                </div>

                <p>
                    Here is the link to the full code: <a href="https://github.com/aligotmelody/Oauth_lab" target="_blank" style="color: rgb(0, 255, 0);">Oauth_lab</a>
                </p>

                <p>
                    also there are some things that I didn't mention here <span class="accent">(intentional vulnerabilities)</span> which I highlighted in the repo
                </p>

                <div class="prompt">
                    <span class="user">ali</span><span class="host">@blog</span><span class="command">:<span class="cursor"></span></span>
                </div>
            </article>

            <div class="post-navigation">
                <a href="blogs.html" class="btn">cd ../ </a>
            </div>
        </div>
    </div>
</div>
    </main>

    <footer>
        <div class="container">
            <div class="social-links" id="social-links">
                <a href="https://github.com/aligotmelody"><i class="fab fa-github"></i></a>
                <a href="https://www.linkedin.com/in/sanl0wkey"><i class="fab fa-linkedin"></i></a>
                <a href="https://x.com/san_lowkey"><i class="fab fa-twitter"></i></a>
            </div>
            
            <p>ali@blog:~$ <span class="cursor"></span></p>
        </div>
    </footer>

</body>
</html>