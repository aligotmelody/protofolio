<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <base href="https://aligotmelody.github.io/protofolio/">
    <title>OAuth</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAADhCAMAAAAJbSJIAAAAwFBMVEVEyXP///8AAABGznbZ8uE0xmothEywsLBG0HciZDlDxXFBwW5Gz3cLIBI2oVwYRSg0mVg9tGcuiU4ECwYTOCAPLRoZSysOKRcylFU8sWU5qGBCwm9AvGwod0QrgEkJGg8eWTNJSUkUOyIlbD5cXFw4pV4cUi8WQiYvt2FnZ2cKHhHf398mcEAHFQw+Pj4wj1IgICDJycmioqLz8/Nm0YozMzOWlpZycnKFhYXNzc27u7vk5OQVFRUiIiIGEQpZuHkZVSe3AAAP+ElEQVR4nO2d+1/iuhLACzkHA1QE5f0S8bEr6rIrV931nPX+///VbUs7M0kmoUqRsrfzk58S03yb5jWveqU/Xbx9N2DnUhAevhSEhy8F4eFLQXj4UhAevvwfE65+PN9eXFwdfWZjPiRHVxcXt88/VrbfLYR3t+VYrnbVsozkKmno7R1fgCX8B/4tkOddtm9reSYtvWIZOcLHMpWnv/IsT0pbH9MRvij/VD77+nd+5euZ2tiXNIS36v+UFzUvv1JbaK293Uz4U/uXclXuG8Mhsqo39+cmwlf9P47z3IVBJx7rDX7dQGj0YL4BPW9k9KKbkL6js2bLk3l+RdcSNHHcnNnfU5VwheXaAyn23fjUIuSgjU1fOQiPoNRJ7XD4QhG1E2j7kYMQ9jK5XiJ4GcHCcWUnXP1OCjUPqwdDEf2k8b9XVsI76Gg/XaXSMROJ8FcpRbpn5awKK3NV4UPr76yEv2CNSDeFTuedaou/q5DX05t2p30zvU4xYwlv0u5cjm0FpWhMgsrms8rQURmu/r+shLDcT1M8eDFev/gNpqyoTcj0PRltqE601gWv2XKifo91PVSsU6CYJoVerYQwlVZSPPbxeVy4bv62LCtytnTWJ1oPcTn214pa2bltjsCCR1kQinEvKXxqFJ6Vdak6AZNnVe6b9611jcouLQMjU0Ixxv2gMWi/GG0K1lcHIJ6AmPt2mMpu2IkwU0J8RU1CccO0KWiVZfJKxqDlvnO2MnYmzJKQ9qB+OxzvmpyyiOQVZe4r7y2VMa9zloRkDJqEY0ubyuUxC/hAi2j3FQNbXYvRLgmTZYIl9I3DDMilOXqE9jx0Qv6FD4VZzzIjFPVz9WYKYQ2v95aD8eAU3+c3Y1kRrTcnIeFvh5VV8M7HTMMyIlTHoE5IVsKbaGmWZLbXB486Bs37kiFd9cJf/DqekczdgWgmv9n3NCkItTGoE0pYCtvwHwuuYFTVm16Vel8Jy85JfF2MYNhOmCbGy85TaQtCZZngCIEfNnP4aL+oVbWMmnRCuD5MrsvT5FKXGdWN9U93WxCKuq6907smecYPeMCEoXmuAprPSr9vcrmDl2BoHjOLjxjMOp2Xf0ofJ2ReUY1wlOxPeuQi/BM5VrOA2n2B5gQrg2nujF1eZe0/pdLHCdVJBrQGlLDOEcLGq0aqomAwGaUghCZY9khbESrLxGS4BSHdiwa7neucEEq6o57IxjZ9OCdVTbGqrQl9uQ3hEBtVvvfFFoTimlQ19XG23ZJQtGa93u2HZxpsR9iD3laE5FBbkV5WhCLug4+uFogUrbZbEYJaLATMjNCLdzzfPvqWwroWbSe2IcS2T8NiWRFCebuuzU2YPPn7qO6tCJPXdBptTDIixNH9UULPbwRt7fXXVW9F6Ml+sA3oNOOq8tKHoV621fKSTfBWhEEtrVaiLM5sHMY3+vA41Gi3I1Sqyngu/fXHEgY775uzN92v5o8iDM2lW+1LD4Bwy513QVgQ7p5Q1gf/1Z0UMyaEMz5RMoDLy9k7CevJ5S+EMFGTvHFzaWVRLv8+2imhSBpwhspRaCij43QSiuRyDx8NqK96zHoYax8fd0ko4Y1cJld9OCp1bfotCyHq2sBk6IPldebYtdnt+BkQglL/PLZZC+jCeMv+DkJQ6vdiwy8xZJhqfdRG/9jlW4rH5E5LCiHkALVXnD3cRShAOVpu16PKhqjeGZjVZGsDthDi2Alk1m8siTm4Z/PRsRF6I1JZNaiMGGraTDWfREhdFFSZ2hw8rITi0loZ4xnwSYTeiNP0hrKwV2Uj9MZnlsqYLvw0QqqwUoR3JXEToplCk8FubcBOQk/y76n1HXURMj7AkSy5yjInBK3IpXY7yY2ee5fN1aIRjn4zPVdsTytrQrQMGV4DjLOC6XNDBTYqzHrCTF2cm8IuCJOuYmYQxZ81kHnL7SeX2FXbrDFhqBq8Tmzub9n34foFOuZcLDzZ6CYG3rebxmY/wMj61Gar8oRsdpM59Xw2tFaWPaEnhveXfYsjnZDj68pl9b4yHKfxphaN+8um/degsmlQ2emw7qhsB4Sh16drAhHp3Us3VJWqsl0Q5ksKwoIw/1IQFoT5l4KwIMy/FIQFIa0qDLLyN+6phR8V21QqKpY+mlNYy2bmBS0Hy2r3pDurDF2MQgxPZ0Gx6qkrGCssVomKLdOFrIr6pNud8ie2bAiFWGIQy2Jii7IS3hRV3b1Tz1asNsFghE5/80lLDKKj8II9KmdCKK41bSgfskW8uiJ544Ox9Jit3vUGZQCYLdpcWFAWhIxWaMap6k0V4CVXnRlN4VA5euhNEshwN4Ss8nJu3smMNiuXb4waa22mmK6ZVOodoAaceym2J7QEIZ1oZVkNJ2Pv4yLcIr9OKyApthNCq7pebZQ+uEDUIWuN2bKa4KgD724IzQwUiSimPHtklxIUZI/ZskwBQ8VIswtCa98ELyApzar010JNwJIbq2th1eN6FNtO+hC78GwyVEK2lLg7vPpQGYyHU1zwHkgnkgb3ToNiZJI+5hqvd/kOCMkw6EQ6XkGifdGmTlbCbi10cPZHOKNgs8iyMwu3A0K2cGYdum6+JSEkiDLfFGzTWz35cZ5cQo8eH7A7sFDCJgGXAgnhKBCzhePX8EGgy4SLEIyNdkLI3WJuVXxYnitJO8mTxab3jDZgt2JkF3o2galTgsFKjxjmIklZQvDF+GklvEiKmFsGCW0igw62qHi/dJFdYE4jnk1w7UQlZENl2W0gPPELGyEkjWAc0CRYf3C+wCAauMZFdtXMyC6gIf5c4B+k7pK0ZcJFiPGrdxbCb3Bf87/h/seEEEYT9GtKzz0g7DKEiheC2oPwSPmt/Dz5+RtPiHnamDDiPRGqgH2YS1hCYnt+YQhXJE8bc/zaE2GNntaWEtYDvg/Jfup2pRKu7p7/xV9nzL/vh1A5aC6l2EBIN/3/Pt+tEsLHp+8EL5AW88/7IaR7wFPpbSL01NDif78/PYaEF2VN2GPonvoQ9z6hC81GQml4gVyUvEf9Wpc9oe1pHMISF/kIbSRkdvSP3pN2pc17EO6JMElCsXaC2kxoag6ePO1C2ZL3aW/rYfieHsf+KikIzSj/nPdhcNkbthJV6sf6MN/jUJWPjcNcz6XvJWTn0lyvh+8l5NfDSO6ev+Mv+dnTvJOQ7mm+P9/p+1KSIDk/+9L3EZJ96Yu2L83t2eJdhGQHxJ0ttjofwrX99uE8+dlyPiSpL11nfHyF8YwPmbdSRnZxZ3yI1JjbXd7dhJvP+E49DagicKZF9QSqCZnILogLwcguHDBICGfdE3ZBTkG4WU+TTtc2SWx3JI0E6trgjQRnbJL4CGodwbPB/EhgyGBitlIRptG1ufSluJYmO9ca0KD+Dw1wi1itKjC0h9OXJoOOqCscabjchCn0pS6tPrZgMYiirOqozMYHQgxU7XFUrIVWcTQrkefVjWO2MAGVGbOVknBbuwVJQjlrDhv3RMlHrUp4tXzZHDaJUZVmXyabj7NJY0jzcXccoSc7JdSzrhKpktIpI7skb0YNxRJNsXtCPpNoJMo+tv5gKXWuLEFWM6OjC3dNaBqAksKqDbhvKaYad81TQCym5enTCD3UViqiT+4+byPVQ2QteS35LKefRMhHpZlOFqzLBpP7l0Pc4G7i1Hln4k9jhgNyjjLMbMOmzzY7m426IxXDHoNbUbLxiWrNlRad854TQgvG6vDBSqKpzkpfLFowFD+ul9W0ZOS551+jJqS9tHmiCdnER/GlaS0m+jhBdzf5fIWyTtzIa8uy802sN6bVWXXSbDmdDuW4MQmKTRvOyK5gz9NcF3PFbFFZVqsWFUaW/qVC+pvdS0PPUT9FZFfKYlDc37V/aX6lICwI8y8FYUGYfykIC8L8S0FYELJ1bkiEkBRzBm6lS72wn5wK4tqeF4NK49Ka8yI8ZKXIeLGvvBhxbpMNZWuRbnxufvcq7JgmKM7tWUuEj7lNHj4zt4mIG2fPcBWVGsWn+LkZjOVfq8qOLvuw9pefBrQZDiW1J/C7KYYiVJhhM00mGeLecgyhusYVjTVCBx7DnsUp9it6XXvLE0Xj0xyfEqwRS4BGaAkA62uJw/aW64sGnlkJYQwyhOkyse0vX5viW2UlrCs+Ziqh1TLTprXtLeee6jxmI9Sc6BRCh3WN6Ar3lTdRnKg3sxDWNGucQki78LLfWJJnRjpxX7kvNUDLp/rqurmREpJQvy9rK/c1KvjBJrGv/KWGfyNLODKifCkhOkkmn3KSQ7Pge3PQZkPIhDFzhPorqhGiJw5kxES3/Fmy+3HnETb2SBllHGDik01CdZlgCNN5DL0zF3Q2hFxwq0Eo6lwgOiVM5/XF5fMe2/N5Z0JIAeFFMwiVZQJ6kyV0eu4BYcqvsGxPqIzBri1DqzoGq+BC9H7C935nZntPBbpKdzFDq/5ZQ/ocqhJcMw6AkDpRd+15hKlTStUXB0RIcyp0PTshcZSpCu9ACbuegxC3K6E32CER4g27noMQ17Xo+kERJg5DXc9JmBxt1/58B0UYq0ziz6RbCeMEPPG3Xg+L0JOjZrPubyT06/1mokY9MMJQwwl/2QmVYodGSOpzEZJiBWFBWBAWhAXhrglPGELI3sKegO3f5c4n4QPRT5g8yZV031bPFSF+hB5iNfDTXhBFhbo2jP/CMLEd6doyIsTIxaSh5NNeoAnFUpAvawSK48mu9KXZEBKzZzVKbuqP52aHkcN0XIoo8cxPD+WKkGaka/db4wFJXEcy0hHrRns5CEphPh7mO3z5IpSMZtm8tyWuJhQmgCNfhGyKskjeRJpSi5Fxp5wR2szXWgCYNQforqKCMiSET71rogeAzdlSvEFvT4SszjuUkeomE9dl3JiLerzhEiVn708DE53ze1yoIDZCpGq6qTXoQbPpNdMYZPnCWfbf7EpuzX+HCiR+G8+ZKrUoyx776Ss9NezClpsmDeFrUoQNptMl3ubbEv8mEu9BWf+QMZlJHmyJzUWdlqpYXQVxg/BqJYTUkM6hhVKZty83Oe6Fidfb7fs6X0yKxqTb7sxnp66s81I2JjdhqYorhT1Oz7+shJgYgx3KZuOlTPMonP6lIv4OwYYqolJub1bcqN9ZCVe/kzIub7ycCq5Lv+3fAy5dwXC2ffc1vzKCE9lVyU4Ik2n5JIXvb55EkLXnyEG4wkmrne6DE/kQoXxTcuUgxPwt5TD7xdhLNZPsV4ImjmlejfJzyUVYKmtSZTbxuZKRsYUvuQlf9fI5n3NqC73BrxsIlfd03Yt5flHNQ9hPHcggLN1q/5LrTjS68NbgMQlJ3rZIzr7+nV/5qjkRv5g4DGFJTYf59FeeRU1O+sjQcISlf67Ifz1zJXIjz6SlV3dcCZYw2IPDaLziC+RGoDNeWD4rYSA/nm8vLq6OrL/nRY6uLi5un39Yf7cT/ilSEB6+FISHLwXh4UtBePhSEB6+FISHL/8Dr0KYuUoS5IwAAAAASUVORK5CYII=" type="image/x-icon">
    <style>
        li{
            text-indent: 2em;
        }
       
    </style>
</head>
<body>
    <main>

<div class="blog-container">
    <header>
        <div class="container">
            <div class="header-content">
                <a href="#" class="logo">ali@<span>blogs</span>:$</a>
                <nav>
                    <ul>
                        <li><a href="/protofolio/">home</a></li>
                        <li><a href="/protofolio/blogs.html">blogs</a></li>
                    </ul>
                </nav>
            </div>
        </div>
    </header>

    <div class="terminal-window post-container">
        <div class="terminal-header">
            <div class="terminal-buttons">
                <span class="terminal-button close"></span>
                <span class="terminal-button minimize"></span>
                <span class="terminal-button maximize"></span>
            </div>
            <div class="terminal-title">view_post.sh --target open_authorization.md</div>
        </div>

        <div class="blog-terminal-body">
           

            <article class="post-content">
                <header class="post-header">
                    <h1 class="section-title">Open Authorization</h1>
                    <div class="post-metadata">
                        [DATE: 2025-01-02] [AUTHOR: ALI] [TAGS: SECURITY, WEB]
                    </div>
                </header>

                <p>
                    <span class="highlight">Open Authorization</span> a secure, standardized framework that lets users grant a third-party application limited access to their data on another service (like Google or Facebook) without sharing their password 
                </p>
                
                <h3>introduction:</h3>
<p>hey there, in this blog post I&#39;ll try to simplify how OAuth works and break down what actually happens behind the scenes.</p>
<p>so I built a small server and a segment of the client app of which would handle the OAuth request.
I decided to take this approach because I couldn&#39;t really pinpoint the attack vectors of OAuth with just the theory of how it works, I needed to build it in order to understand how to break it, anyhow enough with the introduction let&#39;s get into it.</p>
<hr>
<br>
<p>so before we start anything let&#39;s make sure you guys understand the terminology that will be used add to that I will give you a mental model of the context which we will be implementing the OAuth functionality :</p>
<h4>Terminology :</h4>
<ul>
<li><strong>The Frontchannel (The User&#39;s Browser)</strong></li>
</ul>
<p>The Frontchannel is like a public courier. When the Auth Server wants to send a code to the Client App, it gives it to the browser (the courier) via a URL redirect.</p>
<p><em>The Risk:</em> Because the data is in the URL, it&#39;s visible in browser history, server logs, and can be intercepted by malicious browser extensions.</p>
<p><em>Analogy:</em> Sending a postcard. Anyone who handles the postcard can read what&#39;s written on the back.</p>
<ul>
<li><strong>The Backchannel (Server-to-Server)</strong></li>
</ul>
<p>The Backchannel is like a private secure line. Once the Client App has the temporary code, it calls the Auth Server directly over a secure HTTPS connection (using a library like axios or fetch).</p>
<p><em>The Security:</em> This connection is encrypted. The user never sees the data being exchanged (like the code_verifier or the access_token).</p>
<p><em>Analogy:</em> A private phone call between two offices. No one on the street knows the conversation is even happening.</p>
<p>In this system, the flow moves between the <strong>User&#39;s Browser</strong> (Frontchannel) and <strong>Server-to-Server</strong> (Backchannel) to ensure security. Here is the breakdown of the requests in order:</p>
<h4>Mental model:</h4>
<p>To make it clear, the server I built is a <strong>Custom OAuth 2.0 Authorization Server</strong> using the <strong>PKCE</strong> extension.</p>
<p>While Google acts as a &quot;Public Identity Provider&quot; for the whole world, this server is currently a &quot;Private Identity Provider.&quot; Here is the exact context where this type of server is used:</p>
<h5>1. The &quot;Internal Ecosystem&quot; Context</h5>
<p>This is the most common real-world use case. Imagine you are building a company called &quot;TechCorp&quot; that has:</p>
<ul>
<li>A <strong>Main API</strong> (Resource Server) that holds user data.</li>
<li>A <strong>Mobile App</strong> (iOS/Android).</li>
<li>A <strong>Web Dashboard</strong> (React/SPA).</li>
<li>A <strong>Desktop Tool</strong>.</li>
</ul>
<br>
<p>Instead of writing login logic for <em>each</em> app, you build <strong>one</strong> Authorization Server (the one used here). All your different apps &quot;Sign in with TechCorp&quot; by talking to this single server. It centralizes your security.</p>
<h5>2. The &quot;Third-Party Developer&quot; Context</h5>
<ul>
<li><p><strong>Context:</strong> You have a platform (like a CRM or E-commerce engine) and you want outside developers to build &quot;Apps&quot; or &quot;Plugins&quot; for it.</p>
</li>
<li><p><strong>Role:</strong> You give those developers a <code>client_id</code>, and they use the flow we built to let users &quot;Authorize&quot; their third-party apps to access your platform&#39;s data.</p>
</li>
</ul>
<h5>Why we used PKCE specifically?</h5>
<p>this server is specifically designed for <strong>Public Clients</strong>. These are apps where the source code is visible to the user (like a Mobile App or a React site).</p>
<ul>
<li><strong>Without PKCE:</strong> A hacker could intercept the <code>code</code> from the browser and use it.</li>
<li><strong>With PKCE:</strong> Even if they steal the <code>code</code>, they can&#39;t use it because they don&#39;t have the <code>code_verifier</code> hidden inside the app&#39;s memory.</li>
</ul>
<br>
<hr>
<br>
<p><strong>uml diagram showing the client_app and server interaction:</strong></p>
<img src="https://8upload.com/image/9a1752147ecbb01d/uml_diagram.png" alt="uml diagram showing the interaction between the server and the client_app" style="object-fit: scale-down; width: 850px; height: 600px;: 600px;"> <br><br>
<h3>Step 1: The Setup (Client App Internal)</h3>
<p>Before any request is made, the Client App prepares a &quot;secret handshake.&quot;</p>
<ul>
<li><p><strong>Functionality:</strong> The client generates a <code>code_verifier</code> (a random string) and a <code>code_challenge</code> (a hash of that string).</p>
</li>
<li><p><strong>Purpose:</strong> To prove later that the app that started the login is the same one that finishes it.</p>
</li>
</ul>
<pre><code class="language-node">// Step 1: The Setup (Client App Internal)

// Helper: Generate a random string for PKCE
const generateRandomString = () =&gt; crypto.randomBytes(32).toString(&#39;hex&#39;);

// Helper: Hash the string for PKCE (S256)
const generateCodeChallenge = (verifier) =&gt; {
	return crypto.createHash(&quot;sha256&quot;).update(verifier).digest(&quot;base64url&quot;);
};
</code></pre>
<br>
<h3>Step 2: The Authorization Request (Frontchannel)</h3><br>
<p><strong>Endpoint:</strong> <code>GET http://localhost:4000/authorize</code></p>
<ul>
<li><p><strong>The Request:</strong> The browser is redirected from the Client to the Auth Server with parameters like <code>response_type</code> ,<code>client_id</code>, <code>redirect_uri</code>, and the <code>code_challenge</code>.</p>
</li>
<li><p><strong>Functionality:</strong> The Auth Server checks if the <code>client_id</code> exists and if the <code>redirect_uri</code> is on the pre-approved &quot;Allowlist.&quot;</p>
</li>
<li><p><strong>Storage:</strong> The Server generates a temporary <code>authorizationCode</code> and saves the <code>code_challenge</code> in its <code>Map</code>, linked to that code.</p>
</li>
</ul>
<img src="https://8upload.com/image/81f503f251eee5ce/authorize.png" alt="pic showing the authorization request"> <br><br>
<p><strong>client_app</strong>:</p>
<pre><code class="language-node">// Step 2: The Authorization Request (Frontchannel)
app.get(&quot;/login&quot;, (req, res) =&gt; {
	
	// 1. Create PKCE Verifier and Challenge
	currentVerifier = generateRandomString();
	console.log(&quot;verifier :&quot; + currentVerifier)
	const challenge = generateCodeChallenge(currentVerifier);
	console.log(&quot;code challenge :&quot; + challenge)
	
	// 2. Build the Auth Server URL
	const authUrl = `${AUTH_SERVER_URL}/authorize?` +
	
		`response_type=code&amp;` +  // specifying the grant type
		`client_id=${CLIENT_ID}&amp;` +
		`redirect_uri=${encodeURIComponent(REDIRECT_URI)}&amp;` +
		`code_challenge=${challenge}&amp;` +
		`code_challenge_method=S256`;
		
	// 3. Send user to the Auth Server
	res.redirect(authUrl);
});
</code></pre>
<br><br>
<p><strong>server</strong>:</p>
<pre><code class="language-node">app.get(&quot;/authorize&quot;, (req, res) =&gt; {

const {
response_type,
client_id,
redirect_uri,
code_challenge, //the hashed code challenge
code_challenge_method // specification of the hash used
} = req.query;

// 1. Validate response type
if (response_type !== &quot;code&quot;) {
	return res.status(400).send(&quot;Unsupported response_type&quot;);

};

// 2. Validate client
const client = clients[client_id];

if (!client) {
	return res.status(400).send(&quot;Invalid client_id&quot;);
};

// 3. Validate redirect URI
if (!client.redirectUris.includes(redirect_uri)) {
	return res.status(400).send(&quot;Invalid redirect_uri&quot;); // checking the redirect uri against the allow list
};

// 4. Enforce PKCE
if (!code_challenge || code_challenge_method !== &quot;S256&quot;) {
	return res.status(400).send(&quot;PKCE required&quot;);
};

// ---- Fake login success ----
const authorizationCode = crypto.randomBytes(32).toString(&quot;hex&quot;); // Think of this as a &quot;Claim Ticket&quot; a user gives you. It proves that the user just logged in and gave you permission.
console.log(&quot;authorization code :&quot; + authorizationCode + &quot; for client : &quot; + client_id);

authorizationCodes.set(authorizationCode, {
client_id,
redirect_uri,
code_challenge
});

// Redirect back to client

const redirectUrl = `${redirect_uri}?code=${authorizationCode}`;
res.redirect(redirectUrl);

});
</code></pre>
<br>
<p><em>side note :</em> so here is a fun fact about the request to <code>app.get(&quot;/authorize&quot;)</code> so at first I thought we should use the <em>post method</em>  here but turned out standard APIs usually use <code>POST</code> for creating data, but the OAuth 2.0 specification (RFC 6749 section 3.1) actually <strong>requires</strong> the <code>/authorize</code> endpoint to support the <strong><code>GET</code></strong> method for multiple reasons (mainly because it&#39;s a redirect) .</p>
<br>
<h3>Step 3: The Code Delivery (Frontchannel)</h3><br>
<p><strong>Endpoint:</strong> <code>GET http://localhost:3000/callback</code></p>
<ul>
<li><p><strong>The Request:</strong> The Auth Server redirects the user’s browser back to the Client’s callback URL, attaching the <code>code</code> in the URL.</p>
</li>
<li><p><strong>Functionality:</strong> The Client App catches this code from the URL.</p>
</li>
<li><p><strong>Security Note:</strong> At this point, the Client has the <strong>Code</strong>, but it doesn&#39;t have a <strong>Token</strong> yet.</p>
</li>
</ul>
<p> as shown in the response section of the <em>The Authorization Request</em>:
  <img src="https://8upload.com/image/b800ace9bd4ac246/callback.png" alt="pic showing the callback request" ">
<p><strong>at this point we finished the front channel section of the uml diagram :</strong></p>
<img src="https://8upload.com/image/08d4aa3bb96a54c8/front_channel.png" alt="the front channel section of the uml diagram" > <br><br>
<br>
<h3>Step 4: The Token Exchange (Backchannel)</h3><br>
<p><strong>Endpoint:</strong> <code>POST http://localhost:4000/token</code></p>
<ul>
<li><p><strong>The Request:</strong> The Client App sends a direct &quot;Backchannel&quot; POST request to the Server containing the <code>code</code> and the original <code>code_verifier</code>.</p>
</li>
<li><p><strong>Functionality:</strong> 1. The Server retrieves the saved <code>code_challenge</code> from its <code>Map</code>. 2. It hashes the <code>code_verifier</code> sent by the client. 3. If <code>Hash(verifier) === challenge</code>, it proves the request is legitimate.</p>
</li>
<li><p><strong>Cleanup:</strong> The Server <strong>deletes</strong> the code from its <code>Map</code> (making it single-use).</p>
</li>
</ul>
<pre><code class="language-node">app.get(&quot;/callback&quot;, async (req, res) =&gt; {
const { code } = req.query;
if (!code) return res.send(&quot;No code received from Auth Server.&quot;);

try {

// 4. Exchange the Code for a Token
// We send the &#39;currentVerifier&#39; that we saved earlier
const response = await axios.post(`${AUTH_SERVER_URL}/token`, {
	grant_type: &quot;authorization_code&quot;,
	code: code,
	redirect_uri: REDIRECT_URI,
	client_id: CLIENT_ID,
	code_verifier: currentVerifier
}

// uncomment if you want to see the request using a proxy
// ,{
// proxy: {
// protocol: &#39;http&#39;,
// host: &#39;127.0.0.1&#39;,
// port: 8080
// }}
);
const { access_token } = response.data;
</code></pre><br>
<p>side note: some of you might be wondering why are we sending different grant_type parameters (response_type, grant_type) so here is an explanation of the difference :</p>
<ol>
<li><p><strong><code>response_type</code></strong>: Tells the server what to send back to the <strong>user&#39;s browser</strong> (a &quot;code&quot; or a &quot;token&quot;).</p>
</li>
<li><p><strong><code>grant_type</code></strong>: Tells the server what credentials the <strong>Client App</strong> is presenting to the private API (an &quot;authorization_code&quot;, a &quot;password&quot;, etc.).</p>
</li>
</ol>
<p>the request won&#39;t normally show because it is not supposed to (we don&#39;t want the verifier to show ), we used <strong>axios</strong> as shown in the code to make the call  (which creates a direct TCP connection from the terminal process to port 4000.)</p>
<img src="https://8upload.com/image/b5a77bb01771d545/token_request.png" alt="pic showing the token request" style="object-fit: fill;  width: 100vh ;"><br>
<br>
<h3>Step 5: The Response (Backchannel)</h3><br>

<ul>
<li><p><strong>Functionality:</strong> The Server sends the <code>access_token</code> back to the Client.</p>
</li>
<li><p><strong>Result:</strong> The Client App now has a valid token to make API requests, and the user is officially &quot;logged in.&quot;</p>
</li>
</ul>
<p> <strong>as shown in the response section:</strong>
<img src="https://8upload.com/image/0e35f415ee851567/acces_token.png" alt="pic showing the access token in the response section of the request" style=" object-fit: fill; width: 900px;height:400px;">
<p>here is link to the full code : <a href="https://github.com/aligotmelody/Oauth_lab/tree/main" style="color: rgb(0, 255, 0);">OAuth lab</p>
<p>also there are some things that I didn't mention here <strong>(intentional vulnerabilities)</strong> which I highlighted in the repo </p>

                </div>

                <div class="prompt">
                    <span class="user">ali</span><span class="host">@blog</span><span class="command">:<span class="cursor"></span></span>
                </div>
            </article>

            <div class="post-navigation">
                <a href="blogs.html" class="btn">cd ../ </a>
            </div>
        </div>
    </div>
</div>
    </main>


<footer>
        <div class="container">
            <div class="social-links" id="social-links">
                <a href="https://github.com/aligotmelody"><i class="fab fa-github"></i></a>
                <a href="https://www.linkedin.com/in/sanl0wkey"><i class="fab fa-linkedin"></i></a>
                <a href="https://x.com/san_lowkey"><i class="fab fa-twitter"></i></a>
                
            </div>
            
            <p>ali@blog:~$ <span class="cursor"></span></p>
        </div>
</footer>

</body>
</html>